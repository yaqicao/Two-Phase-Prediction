#1.Full Data - Estimation
#Fit logistic regression to full data as benchmark
Dat_fullFit <- function(data){
  #data: generated by Dat_format("Benchmark")
  # Directly fit the logistic model 
  m <- glm(y ~ x1 + x2 + x3 + z, family=binomial, data=data)
  yhat.full <- m$fitted.values
  beta.full <- m$coefficients
  beta.var.full <- summary(m)$cov.unscaled
  X <- cbind(rep(1,nrow(data)), data$x1, data$x2, data$x3, data$z) #Design matrix
  data <- cbind(data, yhat.full)
  
  # Score for each subject: case/control
  S1_beta <- apply(cbind(X, yhat.full), 1, function(x) x[1:5]*(1-x[6]))
  S0_beta <- apply(cbind(X, yhat.full), 1, function(x) x[1:5]*(0-x[6]))
  
  # inverse of -dS/dbeta*(1/n)
  I_betabeta <- solve(t(X) %*% diag(as.vector(yhat.full*(1-yhat.full))) %*% X/n)
  
  # influence function 
  h1 <- I_betabeta %*% S1_beta
  h0 <- I_betabeta %*% S0_beta
  return(list(h1=h1, h0=h0, yhat.full=yhat.full, beta.full=beta.full, beta.var.full=diag(beta.var.full)))
}

#2. Estimation-without G
#Fit Two-Phase maximum likelihood model
Dat_mleFit <- function(data_list){
  # data_list: generated by Dat_format("MLE")
  fdat.mle <- data_list$fdat.mle
  dat2.mle <- data_list$dat2.mle
  dat1.mle <- data_list$dat1.mle
  dat <- data_list$dat
  w1 <- data_list$w1
  w0 <- data_list$w0
  mu_1 <- data_list$mu_1
  mu_0 <- data_list$mu_0
  nn0 <- data_list$nn0
  nn1 <- data_list$nn1
  n0 <- data_list$n0
  n1 <- data_list$n1
  case=fdat.mle$cases
  
  x=cbind(rep(1,nrow(fdat.mle)),fdat.mle$x1,fdat.mle$x2,fdat.mle$x3,fdat.mle$z)
  N=fdat.mle$cases+fdat.mle$conts
  
  mod<- tps(cbind(cases, conts) ~ x1+x2+x3+z, data=fdat.mle, nn0=nn0, nn1=nn1, group=rep(1,nrow(fdat.mle)), method="ML", cohort=T)
  beta.mle <- mod$coef
  XX2 <- cbind(rep(1,nrow(dat2.mle)), dat2.mle$x1, dat2.mle$x2, dat2.mle$x3, dat2.mle$z)
  yhat2.mle <- exp(XX2 %*% beta.mle)/(1 + exp(XX2 %*% beta.mle))
  gamma_i <- matrix(NA, 2, 1)
  
  gamma_i[1,] <- 1
  for(itr in 1:40)
  {
    mm1 <- (n1-gamma_i[1])/(nn1-gamma_i[1,])
    mm0 <- (n0+gamma_i[1,])/(nn0+gamma_i[1,])
    gamma_i[1,] <- n1-sum(yhat2.mle*mm1/(mm0*(1-yhat2.mle)+yhat2.mle*mm1))
    itr=itr+1
  }
  gamma_i[2,] <- -gamma_i[1,]
  
  Q_i <- matrix(NA, 2, 1)
  
  Q_i[1,] <- (nn1-gamma_i[1,])/(nn0+nn1)
  Q_i[2,] <- (nn0-gamma_i[2,])/(nn0+nn1)
  
  dat11.mle <- data.frame(count(dat, vars=c("y")))
  
  strata_mat <- matrix(NA, 4, 1)
  
  strata_mat[1,] <- n1
  strata_mat[2,] <- n0
  strata_mat[3,] <- nn1-n1
  strata_mat[4,] <- nn0-n0
  
  u_i <- matrix(NA, 2, 1)
  for (i in 1:2){
    u_i[i, 1] <- 1 - strata_mat[i+2, 1]/(sum(strata_mat[,1])*Q_i[i, 1])
  }
  
  # All things that we need to calculate based on above information obtained 
  W <- 0
  B <- matrix(NA, numbeta, 1)
  A <- matrix(NA, 2, 1)
  
  counts <- dat2.mle$cases+dat2.mle$conts
  x1 <- dat2.mle$x1
  x2 <- dat2.mle$x2
  x3 <- dat2.mle$x3
  z <- dat2.mle$z
  X <- cbind(rep(1,length(x1)),x1,x2,x3,z) 
  u <- c(u_i[1, 1], u_i[2, 1])
  ystar.mle <- u[1]*yhat2.mle/(u[1]*yhat2.mle+u[2]*(1-yhat2.mle))
  
  #W
  W <- sum(counts*(ystar.mle*(1-ystar.mle)))
  #B
  B[, 1] <- t(X) %*% (counts*ystar.mle*(1-ystar.mle))
  #A
  A[, 1] <- c(1/(strata_mat[1,1]-gamma_i[1,1])-1/(strata_mat[1,1]+strata_mat[3,1]-gamma_i[1,1]),
              1/(strata_mat[2,1]-gamma_i[2,1])-1/(strata_mat[2,1]+strata_mat[4,1]-gamma_i[2,1]))    
  
  A_0 <- apply(A, 2, sum)
  K <- 1/A_0-W
  dgamma_1 <- matrix(NA, numbeta, 1)
  dgamma_1[,1] <- -B[,1]/(1-A_0*W)
  
  
  #covariate distribution NPMLE estimates for each strata: f(x1,x2,x3,z)
  #since x1,x2 are continuous, each unique value will only be counted once
  #f(x1,x2,x3,z) is a function of beta
  f.mle <- numeric(nrow(dat2.mle))
  df <- matrix(NA, numbeta, nrow(dat2.mle)) #df(x1,x2,x3,z)/dbeta
  s_2 <- matrix(NA, numbeta, nrow(dat2.mle)) #score for R_k=1
  for (k in 1:nrow(dat2.mle)){
    y <- dat2.mle[k, "cases"]
    x1 <- dat2.mle[k, "x1"]
    x2 <- dat2.mle[k, "x2"]
    x3 <- dat2.mle[k, "x3"]
    z <- dat2.mle[k, "z"]
    counts <- dat2.mle[k, "cases"]+dat2.mle[k, "conts"]
    u <- c(u_i[1,1], u_i[2,1])
    yfit.mle <- yhat2.mle[k]
    dgamma <- dgamma_1[, 1]
    a <- A[,1]
    
    f.mle[k] <- counts/(sum(strata_mat[,1])*(u[1]*yfit.mle+u[2]*(1-yfit.mle)))
    df[,k] <- -counts/(sum(strata_mat[,1])*(u[1]*yfit.mle+u[2]*(1-yfit.mle))^2)*(c(1,x1,x2,x3,z)*yfit.mle*(1-yfit.mle)*(u[1]-u[2])+dgamma*((1-yfit.mle)*u[2]*a[2]-yfit.mle*u[1]*a[1]))
    s_2[, k] <- c(1,x1,x2,x3,z)*(y-yfit.mle) + df[, k]/f.mle[k]
  }
  
  s_1 <- matrix(NA, numbeta, nrow(dat11.mle)) #score for R_k=0
  for (k in 1:nrow(dat11.mle)){
    y <- dat1.mle[k, "Death"]
    Q <- NULL
    if (y==1){
      Q = Q_i[1, 1]
      s_1[, k] <- -dgamma_1[, 1]/sum(strata_mat[,1])/Q
    }
    else{
      Q = Q_i[2, 1]
      s_1[,k] <- dgamma_1[, 1]/sum(strata_mat[,1])/Q
    }
  }
  #S_1 <- apply(rbind(s_1, c(strata_mat[4, ], strata_mat[3, ])), 2, function(x) x[1:2]*x[3])
  #S_2 <- apply(rbind(s_2, dat2.mle$counts), 2, function(x) x[1:2]*x[3])
  #apply(S_2, 1, sum) + apply(S_1, 1, sum)
  
  ## Influence function for odds ratios
  h_1 <- mod$covm %*% s_1*n
  h_2 <- mod$covm %*% s_2*n
  
  emp_cov <- matrix(0, numbeta, numbeta)
  counts2 <- c(strata_mat[4,], strata_mat[3,])
  for (k in 1:ncol(h_1)){
    emp_cov = emp_cov + h_1[, k] %*% t(h_1[, k])*counts2[k]
  }
  for (k in 1:ncol(h_2)){
    emp_cov = emp_cov + h_2[, k] %*% t(h_2[, k])*(dat2.mle$cases[k]+dat2.mle$conts[k])
  }
  # check emp_cov/n^2 = mod$covm
  
  return (list(beta.mle=beta.mle, beta.var.mle=diag(mod$covm),h1=h_1, h2=h_2, yhat.mle=yhat2.mle, f.mle=f.mle, df_beta=df, strata_mat=strata_mat))
}

#3. Estimation - with G
#Fit Two-Phase maximum likelihood model (With G)
Dat_mleFitG <- function(data_list){
  # data_list: generated by Dat_format("MLE")
  fdat.mle <- data_list$fdat.mle
  dat2.mle <- data_list$dat2.mle
  dat1.mle <- data_list$dat1.mle
  dat <- data_list$dat
  w1 <- data_list$w1
  w0 <- data_list$w0
  mu_1 <- data_list$mu_1
  mu_0 <- data_list$mu_0
  nn0 <- data_list$nn0
  nn1 <- data_list$nn1
  n0 <- data_list$n0
  n1 <- data_list$n1
  case=fdat.mle$cases
  group=fdat.mle$G
  x=cbind(rep(1,nrow(fdat.mle)),fdat.mle$x1,fdat.mle$x2,fdat.mle$x3,fdat.mle$z)
  N=fdat.mle$cases+fdat.mle$conts
  
  mod <- tps(cbind(cases, conts) ~ x1+x2+x3+z, data=fdat.mle, nn0=nn0, nn1=nn1, group=fdat.mle$G, method="ML", cohort=T)
  #beta.mle <- mod$coef
  beta.mle <- mod$coef
  #XX <- cbind(rep(1,nrow(fdat.mle)), fdat.mle$x1, fdat.mle$x2, fdat.mle$x3, fdat.mle$z) # Design matrix
  #yhat.mle <- exp(XX %*% beta.mle)/(1 + exp(XX %*% beta.mle))
  XX2 <- cbind(rep(1,nrow(dat2.mle)), dat2.mle$x1, dat2.mle$x2, dat2.mle$x3, dat2.mle$z)
  yhat2.mle <- exp(XX2 %*% beta.mle)/(1 + exp(XX2 %*% beta.mle))
  gamma_ig <- matrix(NA, 2, numG)
  for(g in 1:numG)
  {
    gamma_ig[1,g] <- 1
    for(itr in 1:40)
    {
      mm1 <- (n1[g]-gamma_ig[1,g])/(nn1[g]-gamma_ig[1,g])
      mm0 <- (n0[g]+gamma_ig[1,g])/(nn0[g]+gamma_ig[1,g])
      gamma_ig[1,g] <- n1[g]-sum(yhat2.mle[which(dat2.mle$G==g)]*mm1/(mm0*(1-yhat2.mle[which(dat2.mle$G==g)])+yhat2.mle[which(dat2.mle$G==g)]*mm1))
      itr=itr+1
    }
  }
  gamma_ig[2,] <- -gamma_ig[1,]
  
  Q_ig <- matrix(NA, 2, numG)
  for(g in 1:numG)
  {
    Q_ig[1,g] <- (nn1[g]-gamma_ig[1,g])/(nn0[g]+nn1[g])
    Q_ig[2,g] <- (nn0[g]-gamma_ig[2,g])/(nn0[g]+nn1[g])
  }
  dat11.mle <- data.frame(count(dat, vars=c("y", "G")))

  strata_mat <- matrix(NA, 4, numG)
  for (g in 1:numG)
  {strata_mat[1,g] <- sum(1*(fdat.mle$G==g)*(fdat.mle$cases==1))
  strata_mat[2,g] <- sum(1*(fdat.mle$G==g)*(fdat.mle$conts==1))
  strata_mat[3,g] <- sum(1*(fdat.mle$G==g)*(fdat.mle$Death-fdat.mle$cases==1))
  strata_mat[4,g] <- sum(1*(fdat.mle$G==g)*(fdat.mle$nonDeath-fdat.mle$conts==1))}

  u_ig <- matrix(NA, 2, numG)
  for (i in 1:2){
    for (g in 1:numG){
      u_ig[i, g] <- 1 - strata_mat[i+2, g]/(sum(strata_mat[,g])*Q_ig[i, g])
      
    }
  }
  
  # All things that we need to calculate based on above information obtained 
  W_g <- numeric(numG)
  B_g <- matrix(NA, numbeta, numG)
  A_g <- matrix(NA, 2, numG)
  p_g <- numeric(numG) #p(G=g)
  for (g in 1:numG){
    #counts <- dat2.mle[dat2.mle$G==g, "counts"]
    counts <- dat2.mle[dat2.mle$G==g, "cases"] + dat2.mle[dat2.mle$G==g, "conts"]
    x1 <- dat2.mle[dat2.mle$G==g, "x1"]
    x2 <- dat2.mle[dat2.mle$G==g, "x2"]
    x3 <- dat2.mle[dat2.mle$G==g, "x3"]
    z <- dat2.mle[dat2.mle$G==g, "z"]
    X <- cbind(rep(1,length(x1)),x1,x2,x3,z) 
    yfit.mle <- yhat2.mle[dat2.mle$G==g]
    u <- c(u_ig[1, g], u_ig[2, g])
    ystar.mle <- u[1]*yfit.mle/(u[1]*yfit.mle+u[2]*(1-yfit.mle))
    
    #W_g
    W_g[g] <- sum(counts*(ystar.mle*(1-ystar.mle)))
    #B_g
    B_g[, g] <- t(X) %*% (counts*ystar.mle*(1-ystar.mle))
    #A_g
    A_g[, g] <- c(1/(strata_mat[1,g]-gamma_ig[1,g])-1/(strata_mat[1,g]+strata_mat[3,g]-gamma_ig[1,g]),
                  1/(strata_mat[2,g]-gamma_ig[2,g])-1/(strata_mat[2,g]+strata_mat[4,g]-gamma_ig[2,g]))    
    #p_g
    p_g[g] <- sum(strata_mat[, g])/sum(strata_mat)
  }
  
  A_0g <- apply(A_g, 2, sum)
  K_g <- 1/A_0g-W_g
  dgamma_1g <- matrix(NA, numbeta, numG)
  for (g in 1:numG){
    dgamma_1g[,g] <- -B_g[,g]/(1-A_0g[g]*W_g[g])
  }
  
  #covariate distribution NPMLE estimates for each strata: f(x1,x2,x3,z,g)=f(x1,x2,x3,z|g)*p(G=g)
  #since x1,x2 are continuous, each unique value will only be counted once
  #f(x1,x2,x3,z,g) is a function of beta
  f.mle <- numeric(nrow(dat2.mle))
  df_g <- matrix(NA, numbeta, nrow(dat2.mle)) #df(x1,x2,x3,z|g)/dbeta 
  df <- matrix(NA, numbeta, nrow(dat2.mle)) #df(x1,x2,x3,z)/dbeta
  s_2 <- matrix(NA, numbeta, nrow(dat2.mle)) #score for R_k=1
  for (k in 1:nrow(dat2.mle)){
    #y <- dat2.mle[k, "y"]
    y <- dat2.mle[k, "cases"]
    x1 <- dat2.mle[k, "x1"]
    x2 <- dat2.mle[k, "x2"]
    x3 <- dat2.mle[k, "x3"]
    z <- dat2.mle[k, "z"]
    #counts <- dat2.mle[k, "counts"]
    counts <- dat2.mle[k, "cases"] + dat2.mle[k, "conts"]
    g <- dat2.mle[k,"G"]
    u <- c(u_ig[1, g], u_ig[2,g])
    yfit.mle <- yhat2.mle[k]
    dgamma <- dgamma_1g[, g]
    a <- A_g[,g]
    f.mle[k] <- counts/(u[1]*yfit.mle+u[2]*(1-yfit.mle))/n
    df_g[,k] <- -counts/(sum(strata_mat[,g])*(u[1]*yfit.mle+u[2]*(1-yfit.mle))^2)*(c(1,x1,x2,x3,z)*yfit.mle*(1-yfit.mle)*(u[1]-u[2])+dgamma*((1-yfit.mle)*u[2]*a[2]-yfit.mle*u[1]*a[1]))
    df[, k] <- df_g[,k]*p_g[g]
    s_2[, k] <- c(1,x1,x2,x3,z)*(y-yfit.mle) + df_g[, k]/f.mle[k]*p_g[g]
  }
  
  s_1 <- matrix(NA, numbeta, nrow(dat11.mle)) #score for R_k=0
  for (k in 1:nrow(dat11.mle)){
    y <- dat11.mle[k, "y"]
    g <- dat11.mle[k, "G"]
    Q <- NULL
    if (y==1){
      Q = Q_ig[1, g]
      s_1[, k] <- -dgamma_1g[, g]/sum(strata_mat[,g])/Q
    }
    else{
      Q = Q_ig[2, g]
      s_1[,k] <- dgamma_1g[, g]/sum(strata_mat[,g])/Q
    }
  }
  #S_1 <- apply(rbind(s_1, c(strata_mat[4, ], strata_mat[3, ])), 2, function(x) x[1:2]*x[3])
  #S_2 <- apply(rbind(s_2, dat2.mle$cases+dat2.mle$conts), 2, function(x) x[1:2]*x[3])
  #apply(S_2, 1, sum) + apply(S_1, 1, sum)
  
  ## Influence function for odds ratios
  h_1 <- mod$covm %*% s_1*n
  h_2 <- mod$covm %*% s_2*n
  emp_cov <- matrix(0, numbeta, numbeta)
  counts2 <- c(strata_mat[4,], strata_mat[3,])
  for (k in 1:ncol(h_1)){
    emp_cov = emp_cov + h_1[, k] %*% t(h_1[, k])*counts2[k]
  }
  for (k in 1:ncol(h_2)){
    emp_cov = emp_cov + h_2[, k] %*% t(h_2[, k])*(dat2.mle$cases[k]+dat2.mle$conts[k])
  }
  # check emp_cov/(n^2) = mod$covm
  
  return (list(beta.mle=beta.mle, beta.var.mle=diag(mod$covm),beta.var.mle.inf=diag(emp_cov/n^2), h1=h_1, h2=h_2, yhat.mle=yhat2.mle, f.mle=f.mle, df_beta=df, strata_mat=strata_mat))
}
