#1.Full Data - Evaluation

# Calculate auc by fitting the logistic regression model
Dat_auc_full <- function(data, fullFit_list, X){
  #fullFit_list: generated by Dat_fullFit(data)
  h1 <- fullFit_list$h1
  h0 <- fullFit_list$h0
  yhat.full <- fullFit_list$yhat.full
  beta.full <- fullFit_list$beta.full
  
  #calculate auc
  #c <- seq(0, 1, by=0.05) #possible threshold values for ROC curve
  c <- c(seq(0, 1, by=0.01)*max(yhat.full),1)
  denom_tpr.full <- sum(yhat.full)
  denom_fpr.full <- sum(1-yhat.full)
  num_tpr.full <- numeric(length(c))
  num_fpr.full <- numeric(length(c))
  for (j in 1:length(c)){
    ind <- (yhat.full>=c[j])
    num_tpr.full[j] <- sum(yhat.full[ind==1])
    num_fpr.full[j] <- sum((1-yhat.full)[ind==1])
  }
  tpr.full <- num_tpr.full/denom_tpr.full
  fpr.full <- num_fpr.full/denom_fpr.full
  auc <- auc(fpr.full, tpr.full)
  
  # numerical method for dFPR/dbeta and dTPR/dbeta as a function of c
  dFPR_beta <- matrix(0, nrow=numbeta, ncol=length(c))
  dTPR_beta <- matrix(0, nrow=numbeta, ncol=length(c))
  yfit1 <- numeric(nrow(data))
  yfit2 <- numeric(nrow(data))
  for (i in 1:numbeta){
    tmp1 <- beta.full
    tmp2 <- beta.full
    tmp1[i] <- beta.full[i] + epsilon_beta[i]
    tmp2[i] <- beta.full[i] - epsilon_beta[i]
    yfit1 <- exp(X %*% tmp1)/(1 + exp(X %*% tmp1))
    yfit2 <-  exp(X %*% tmp2)/(1 + exp(X %*% tmp2))
    num1_tpr <- 0
    num2_tpr <- 0
    num1_fpr <- 0
    num2_fpr <- 0
    denom1_tpr <- sum(yfit1)
    denom2_tpr <- sum(yfit2)
    denom1_fpr <- sum(1-yfit1)
    denom2_fpr <- sum(1-yfit2)
    
    for (j in 1:length(c)){
      ind1 <- (yfit1>=c[j])
      ind2 <- (yfit2>=c[j])
      num1_tpr <- sum(yfit1[ind1==1])
      num2_tpr <- sum(yfit2[ind2==1])
      num1_fpr <- sum((1-yfit1)[ind1==1])
      num2_fpr <- sum((1-yfit2)[ind2==1])
      dTPR_beta[i,j] <- (num1_tpr/denom1_tpr-num2_tpr/denom2_tpr)/(2*epsilon_beta[i])
      dFPR_beta[i,j] <- (num1_fpr/denom1_fpr-num2_fpr/denom2_fpr)/(2*epsilon_beta[i])
    }
  }
  
  # calculate influence function for TPR/FPR as a function of c
  mat_tpr.full <- matrix(0, nrow=nrow(data), ncol=length(c))
  mat_fpr.full <- matrix(0, nrow=nrow(data), ncol=length(c))
  for (j in 1:length(c)){
    ind <- (yhat.full>=c[j])
    mat_tpr.full[,j] <- yhat.full*(ind-tpr.full[j])/(denom_tpr.full/n)
    mat_fpr.full[,j] <- (1-yhat.full)*(ind-fpr.full[j])/(denom_fpr.full/n)
  }
  
  # calculate the influence function for tpr/fpr
  h1_tpr <- t(h1) %*% dTPR_beta + mat_tpr.full
  h0_tpr <- t(h0) %*% dTPR_beta + mat_tpr.full
  h1_fpr <- t(h1) %*% dFPR_beta + mat_fpr.full
  h0_fpr <- t(h0) %*% dFPR_beta + mat_fpr.full
  
  #calcualte influence function for auc
  h1_auc <- 0-apply(h1_fpr, 1, function(x) auc(tpr.full, x))+apply(h1_tpr, 1, function(x) auc(fpr.full, x))
  h0_auc <- 0-apply(h0_fpr, 1, function(x) auc(tpr.full, x))+apply(h0_tpr, 1, function(x) auc(fpr.full, x))
  
  emp_cov_auc <- sum((h1_auc)^2*data$y, (h0_auc)^2*(1-data$y))
  var_auc <- emp_cov_auc/n^2
  return(list(auc=auc, sq_var_auc=sqrt(var_auc)))
}

#2. Evaluation - TwoPhase Data
## Calculate auc by fitting the MLE model
Dat_auc_mle <- function(data_list, mleFit_list){
  #data_list: generated by Dat_format("MLE");
  fdat.mle <- data_list$fdat.mle
  dat1.mle <- data_list$dat1.mle
  dat2.mle <- data_list$dat2.mle
  
  #mleFit_list: generated by Dat_mleFit(data_list)
  fhat.mle <- mleFit_list$f.mle
  yhat.mle <- mleFit_list$yhat.mle
  beta.mle <- mleFit_list$beta.mle
  # influence function for odds ratio
  h1 <- mleFit_list$h1
  h2 <- mleFit_list$h2
  strata_mat <- mleFit_list$strata_mat
  df_beta <- mleFit_list$df_beta
  
  # calculate auc
  denom_tpr.mle <- sum(yhat.mle*fhat.mle)
  denom_fpr.mle <- sum((1-yhat.mle)*fhat.mle)
  c <- c(seq(0, 1, by=0.01)*max(yhat.mle),1)
  num_tpr.mle <- numeric(length(c))
  num_fpr.mle <- numeric(length(c))
  for (j in 1:length(c)){
    ind <- (yhat.mle>=c[j])
    num_tpr.mle[j] <- sum((yhat.mle*fhat.mle)[ind==1])
    num_fpr.mle[j] <- sum(((1-yhat.mle)*fhat.mle)[ind==1])
  }
  tpr.mle <- num_tpr.mle/denom_tpr.mle
  fpr.mle <- num_fpr.mle/denom_fpr.mle
  auc <- auc(fpr.mle, tpr.mle)
  
  # numerical method for dFPR/dbeta and dTPR/dbeta as a function of c
  dFPR_beta <- matrix(0, nrow=numbeta, ncol=length(c))
  dTPR_beta <- matrix(0, nrow=numbeta, ncol=length(c))
  yfit1 <- numeric(nrow(dat2.mle))
  yfit2 <- numeric(nrow(dat2.mle))
  fhat1 <- numeric(nrow(dat2.mle))
  fhat2 <- numeric(nrow(dat2.mle))
  X <- cbind(rep(1,nrow(dat2.mle)), dat2.mle$x1, dat2.mle$x2, dat2.mle$x3, dat2.mle$z) #Design matrix
  for (i in 1:numbeta){
    tmp1 <- beta.mle
    tmp2 <- beta.mle
    tmp1[i] <- beta.mle[i] + epsilon_beta[i]
    tmp2[i] <- beta.mle[i] - epsilon_beta[i]
    yfit1 <- exp(X %*% tmp1)/(1 + exp(X %*% tmp1))
    yfit2 <-  exp(X %*% tmp2)/(1 + exp(X %*% tmp2))
    fhat1 <- fhat.mle + df_beta[i,]*epsilon_beta[i]
    fhat2 <- fhat.mle - df_beta[i,]*epsilon_beta[i]
    
    num1_tpr <- 0
    num2_tpr <- 0
    num1_fpr <- 0
    num2_fpr <- 0
    denom1_tpr <- sum(yfit1*fhat1)
    denom2_tpr <- sum(yfit2*fhat2)
    denom1_fpr <- sum((1-yfit1)*fhat1)
    denom2_fpr <- sum((1-yfit2)*fhat2)
    
    for (j in 1:length(c)){
      ind1 <- (yfit1>=c[j])
      ind2 <- (yfit2>=c[j])
      num1_tpr <- sum((yfit1*fhat1)[ind1==1])
      num2_tpr <- sum((yfit2*fhat2)[ind2==1])
      num1_fpr <- sum(((1-yfit1)*fhat1)[ind1==1])
      num2_fpr <- sum(((1-yfit2)*fhat2)[ind2==1])
      dTPR_beta[i,j] <- (num1_tpr/denom1_tpr-num2_tpr/denom2_tpr)/(2*epsilon_beta[i])
      dFPR_beta[i,j] <- (num1_fpr/denom1_fpr-num2_fpr/denom2_fpr)/(2*epsilon_beta[i])
    }
  }
  
  # calculate influence function for TPR/FPR as a function of c
  mat_tpr_h2.mle <- matrix(0, nrow=nrow(dat2.mle), ncol=length(c))
  mat_fpr_h2.mle <- matrix(0, nrow=nrow(dat2.mle), ncol=length(c))
  for (j in 1:length(c)){
    ind <- (yhat.mle>=c[j])
    mat_tpr_h2.mle[,j] <- fhat.mle*n*yhat.mle*(ind-tpr.mle[j])/denom_tpr.mle
    mat_fpr_h2.mle[,j] <- fhat.mle*n*(1-yhat.mle)*(ind-fpr.mle[j])/denom_fpr.mle
  }
  
  # calculate the influence function for tpr/fpr
  h1_tpr <- t(h1) %*% dTPR_beta
  h2_tpr <- t(h2) %*% dTPR_beta + mat_tpr_h2.mle
  h1_fpr <- t(h1) %*% dFPR_beta
  h2_fpr <- t(h2) %*% dFPR_beta + mat_fpr_h2.mle
  
  # calculate the influence function of auc
  h1_auc <- 0-apply(h1_fpr, 1, function(x) auc(tpr.mle, x))+apply(h1_tpr, 1, function(x) auc(fpr.mle, x))
  h2_auc <- 0-apply(h2_fpr, 1, function(x) auc(tpr.mle, x))+apply(h2_tpr, 1, function(x) auc(fpr.mle, x))
  
  # calcualte the variance of auc
  a <- rep(h1_auc, c(strata_mat[4, ], strata_mat[3, ]))
  b <- rep(h2_auc, (dat2.mle$cases+dat2.mle$conts))
  tmp <- c(a, b)
  var_auc <- t(tmp) %*% (tmp)/n^2
  
  return(list(auc=auc, var_auc=var_auc))
}