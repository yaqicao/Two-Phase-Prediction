#1. Generate Full Data
Dat_gen <- function(n, beta, Rho){
  #n: total number of subjects in phase I
  #beta: log odds ratio
  #p0: pre-specified probability of being selected into phase II for Y=0,G=g (Yaqi:G=g?)
  #ratio: pre-specified number of controls relative to cases
  
  # Phase I sample
  if (Rho == "Independent")
  {x1 <- rnorm(n)
  z <- rnorm(n)}
  if (Rho == "0.3")
  {sigma <- matrix(c(1, 0.3, 0.3, 1), nrow=2, byrow=TRUE) #0.3*sqrt(1)*sqrt(1)
  x1z <- rmvnorm(n, mean=c(0, 0), sigma=sigma)
  x1 <- x1z[,1]
  z <- x1z[,2]
  #cor(x1,z)
  }
  if (Rho == "0.5")
  {sigma <- matrix(c(1, 0.5, 0.5, 1), nrow=2, byrow=TRUE) 
  x1z <- rmvnorm(n, mean=c(0, 0), sigma=sigma)
  x1 <- x1z[,1]
  z <- x1z[,2]
  #cor(x1,z)
  }
  x2 <- runif(n)
  x3 <- rbinom(n, size=1, prob=0.2)
  X <- cbind(rep(1,n), x1, x2, x3, z)
  y <- rbinom(n, size=1, prob=exp(X %*% beta)/(1+exp(X %*% beta)))
  dat <- data.frame(cbind(y,x1,x2,x3,z))
  dat_case <- dat[dat$y==1, ]
  dat_con <- dat[dat$y==0, ]
  dat
}

#2.Generate Phase II data with different sampling designs (CC,BD,R-balanced)

#2.1 Generate Phase II data with Case-Control sampling design
Dat_gencc <- function(dat, n, beta, p0, ratio){
  #n: total number of subjects in phase I
  #beta: odds ratio
  #theta: known odds ratios for x1,x2,x3
  #p0: pre-specified probability of being selected into phase II for Y=0,G=g
  #ratio: pre-specified number of controls relative to cases
  dat_case <- dat[dat$y==1, ]
  dat_con <- dat[dat$y==0, ]
  
  # Phase II sample
  dat2_con <- NULL
  x0 <- sum(y)*ratio
  selected_con <- 0
  tot_con <- 1
  while (tot_con <= nrow(dat_con) & selected_con < x0){
    choice <- rbinom(1, size=1, prob=p0)
    if (choice==1){
      dat2_con <- rbind(dat2_con, dat_con[tot_con, ])
      selected_con <- selected_con + 1
    }
    tot_con <- tot_con + 1
  }
  dat2 <- rbind(dat_case, dat2_con)
  dat2
}

#2.2 Generate Phase II data with Balanced Design
Dat_genBalanced <- function(dat, n, beta, numG, p0, ratio){
  #n: total number of subjects in phase I
  #beta: odds ratio
  #numG: number of stratum defined by variables x1,x2,x3
  #p0: pre-specified probability of being selected into phase II for Y=0,G=g
  #ratio: pre-spefified number of controls relative to cases
  dat_case <- dat[dat$y==1, ]
  dat_con <- dat[dat$y==0, ]
  # Phase II sample
  dat2_con <- NULL
  x0 <- xtabs(~dat$y+dat$G)[2,]*ratio
  for (i in 1:numG){
    dat_con_i <- dat_con[dat_con$G==i, ]
    selected_con <- 0
    tot_con <- 1
    ## controls for stratum G=i
    while (tot_con <= nrow(dat_con_i) & selected_con < x0[i]){
      choice <- rbinom(1, size=1, prob=p0[i])
      if (choice==1){
        dat2_con <- rbind(dat2_con, dat_con_i[tot_con, ])
        selected_con <- selected_con + 1
      }
      tot_con <- tot_con + 1
    }
  }
  dat2 <- rbind(dat_case, dat2_con)
  dat2
}

#2.3 Generate Phase II data with R-balanced Design
Dat_genEb <- function(dat, n, beta, numG, p0, ratio){
  #n: total number of subjects in phase I
  #beta: odds ratio
  #numG: number of stratum defined by variables x1,x2,x3
  #p0: pre-specified probability of being selected into phase II for Y=0,G=g
  #ratio: pre-spefified number of controls relative to cases
  dat_case <- dat[dat$y==1, ]
  dat_con <- dat[dat$y==0, ]
  # Phase II sample
  dat2_con <- NULL
  x0 <- xtabs(~dat$y+dat$G)[2,]*ratio
  for (i in 1:numG){
    dat_con_i <- dat_con[dat_con$G==i, ]
    selected_con <- 0
    tot_con <- 1
    ## controls for stratum G=i
    while (tot_con <= nrow(dat_con_i) & selected_con < x0[i]){
      choice <- rbinom(1, size=1, prob=p0[i])
      if (choice==1){
        dat2_con <- rbind(dat2_con, dat_con_i[tot_con, ])
        selected_con <- selected_con + 1
      }
      tot_con <- tot_con + 1
    }
  }
  dat2 <- rbind(dat_case, dat2_con)
  dat2
}

#3. Format data
#For data without stratum G (e.g. data generated by Case-Control design)
Dat_format <- function(dat, dat2, method){
  #data_list: data generated by Dat_gen;
  #method: MLE/PL/Benchmark
  
  if (method=="MLE"){
    nonDeath <- aggregate(1-dat$y, by=list(x1=dat$x1, x2=dat$x2, x3=dat$x3, z=dat$z), FUN=sum)$x
    dat1.mle <- data.frame(aggregate(dat$y, by=list(x1=dat$x1, x2=dat$x2, x3=dat$x3, z=dat$z), FUN=sum))
    dat1.mle <- data.frame(cbind(dat1.mle, nonDeath))
    names(dat1.mle) <- c("x1","x2","x3","z", "Death","nonDeath")
    
    conts <- aggregate(1-dat2$y, by=list(x1=dat2$x1, x2=dat2$x2, x3=dat2$x3, z=dat2$z), FUN=sum)$x
    dat2.mle <- data.frame(aggregate(dat2$y, by=list(x1=dat2$x1, x2=dat2$x2, x3=dat2$x3, z=dat2$z), FUN=sum))
    dat2.mle <- data.frame(cbind(dat2.mle, conts))
    names(dat2.mle) <- c("x1","x2","x3","z","cases","conts")
    
    # Final = Phase I + Phase II
    fdat.mle <- merge(dat1.mle, dat2.mle, by=c("x1","x2","x3","z"), all=T)
    fdat.mle$cases <- ifelse(is.na(fdat.mle$cases), 0, fdat.mle$cases)
    fdat.mle$conts <- ifelse(is.na(fdat.mle$conts), 0, fdat.mle$conts)
    
    # Estimate u_i = n_i/N_i
    nn1 <- sum(dat$y)
    nn0 <- sum(1-dat$y)
    n1 <- sum(dat2$y)
    n0 <- sum(1-dat2$y)
    
    w1 <- round(n1/nn1, 3)
    w0 <- round(n0/nn0, 3)
    mu_1 <- rep(w1, nrow(fdat.mle))
    mu_0 <- rep(w0, nrow(fdat.mle))
    return(list(fdat.mle=fdat.mle, dat2.mle=dat2.mle, dat1.mle=dat1.mle, dat=dat, w1=w1, w0=w0, mu_1=mu_1, mu_0=mu_0, nn0=nn0, nn1=nn1, n0=n0, n1=n1))
  }
}

#For data with stratum G (e.g. data generated by BD and R-balanced design or G constructed by post-stratification)
Dat_formatG <- function(dat, dat2, method){
  #data_list: data generated by Dat_gen;
  #method: MLE/PL/Benchmark
  
  if (method=="MLE"){
    nonDeath <- aggregate(1-dat$y, by=list(G=dat$G, x1=dat$x1, x2=dat$x2, x3=dat$x3, z=dat$z), FUN=sum)$x
    dat1.mle <- data.frame(aggregate(dat$y, by=list(G=dat$G, x1=dat$x1, x2=dat$x2, x3=dat$x3, z=dat$z), FUN=sum))
    dat1.mle <- data.frame(cbind(dat1.mle, nonDeath))
    names(dat1.mle) <- c("G","x1","x2","x3","z", "Death","nonDeath")
    
    conts <- aggregate(1-dat2$y, by=list(G=dat2$G, x1=dat2$x1, x2=dat2$x2, x3=dat2$x3, z=dat2$z), FUN=sum)$x
    dat2.mle <- data.frame(aggregate(dat2$y, by=list(G=dat2$G, x1=dat2$x1, x2=dat2$x2, x3=dat2$x3, z=dat2$z), FUN=sum))
    dat2.mle <- data.frame(cbind(dat2.mle, conts))
    names(dat2.mle) <- c("G","x1","x2","x3","z","cases","conts")
    
    # Final = Phase I + Phase II
    fdat.mle <- merge(dat1.mle, dat2.mle, by=c("G","x1","x2","x3","z"), all=T)
    fdat.mle$cases <- ifelse(is.na(fdat.mle$cases), 0, fdat.mle$cases)
    fdat.mle$conts <- ifelse(is.na(fdat.mle$conts), 0, fdat.mle$conts)
    
    # Estimate u_ig = n_ig/N_ig
    nn1 <- aggregate(dat$y, by=list(G=dat$G), FUN=sum)$x
    nn0 <- aggregate(1-dat$y, by=list(G=dat$G), FUN=sum)$x
    n1 <- aggregate(dat2$y, by=list(G=dat2$G), FUN=sum)$x
    n0 <- aggregate(1-dat2$y, by=list(G=dat2$G), FUN=sum)$x
    
    w1 <- round(n1/nn1, 3)
    w0 <- round(n0/nn0, 3)
    mu_1 <- sapply(fdat.mle$G, function(x) w1[x])
    mu_0 <- sapply(fdat.mle$G, function(x) w0[x])
    return(list(fdat.mle=fdat.mle, dat2.mle=dat2.mle, dat1.mle=dat1.mle, dat=dat, w1=w1, w0=w0, mu_1=mu_1, mu_0=mu_0, nn0=nn0, nn1=nn1, n0=n0, n1=n1))
  }
}
